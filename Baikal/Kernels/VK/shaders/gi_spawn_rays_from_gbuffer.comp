// Defines
#version 450
#define PI 3.14159265358979323846
#define LIGHT_COUNT 3
#define TILE_SIZE 16
#define RAY_LENGTH 1000.0
#define CMJ_CELL_SIZE 4
#define CMJ_CELL_SAMPLE_COUNT (CMJ_CELL_SIZE * CMJ_CELL_SIZE)
#define RNG_BUFFER_SIZE (256 * 256)
#define RT_EPSILON 0.3
#define GROUP_SIZE 256

// Data types
struct Light
{
    vec4 position;
    vec4 target;
    vec4 color;
    mat4 viewMatrix;
};

struct Ray
{
    vec3 direction;
    uint pixel_idx;
    vec3 origin;
    float max_t;
};

struct BRDFInputs
{
    vec3 albedo;
    float roughness;
    float metallic;
    float transparency;
};

// Bindings
layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE) in;
layout(set = 0, binding = 0) uniform usampler2D gBuffer0;
layout(set = 0, binding = 1) uniform sampler2D gBuffer1;
layout(set = 0, binding = 2) uniform sampler2D gBuffer2;
layout(set = 1, binding = 3) buffer Rays
{
    Ray rays[];
};
layout(set = 1, binding = 4) buffer RayCount
{
    uint rayCount;
};
layout(set = 0, binding = 5) buffer Rng
{
    uint rng[];
};
layout(set = 0, binding = 6) buffer Throughput
{
    vec4 throughput[];
};

layout(set = 0, binding = 7) uniform UBO
{
    vec4 viewPos;
    mat4 view;
    mat4 invView;
    mat4 invProj;
    vec4 params;
    Light lights[LIGHT_COUNT];
} ubo;
layout(set = 0, binding = 8, rg16ui) uniform uimage2D sampleCounters;

// Util functions
// CMJ sampling
uint Permute(uint i, uint l, uint p)
{
    uint w = l - 1;
    w |= w >> 1;
    w |= w >> 2;
    w |= w >> 4;
    w |= w >> 8;
    w |= w >> 16;

    do
    {
        i ^= p;
        i *= 0xe170893d;
        i ^= p >> 16;
        i ^= (i & w) >> 4;
        i ^= p >> 8;
        i *= 0x0929eb3f;
        i ^= p >> 23;
        i ^= (i & w) >> 1;
        i *= 1 | p >> 27;
        i *= 0x6935fa69;
        i ^= (i & w) >> 11;
        i *= 0x74dcb303;
        i ^= (i & w) >> 2;
        i *= 0x9e501cc3;
        i ^= (i & w) >> 2;
        i *= 0xc860a3df;
        i &= w;
        i ^= i >> 5;
    } while (i >= l);
    return (i + p) % l;
}

float RandFloat(uint i, uint p)
{
    i ^= p;
    i ^= i >> 17;
    i ^= i >> 10;
    i *= 0xb36534e5;
    i ^= i >> 12;
    i ^= i >> 21;
    i *= 0x93fc4795;
    i ^= 0xdf6e307f;
    i ^= i >> 17;
    i *= 1 | p >> 18;
    return i * (1.0 / 4294967808.0);
}

vec2 SampleCMJ(uint s, uint n, uint p)
{
    uint sx = Permute(s % n, n, p * 0xa511e9b3);
    uint sy = Permute(s / n, n, p * 0x63d83595);
    float jx = RandFloat(s, p * 0xa399d265);
    float jy = RandFloat(s, p * 0x711ad6a5);

    return vec2((s % n + (sy + jx) / n) / n, (s / n + (sx + jy) / n) / n);
}

vec3 OrthoVector(vec3 n)
{
    vec3 p;

    if (abs(n.z) > 0.0)
    {
        float k = sqrt(n.y*n.y + n.z*n.z);
        p.x = 0; p.y = -n.z / k; p.z = n.y / k;
    }
    else
    {
        float k = sqrt(n.x*n.x + n.y*n.y);
        p.x = n.y / k; p.y = -n.x / k; p.z = 0;
    }

    return p;
}

float nrand(vec2 n)
{
    return fract(sin(dot(n.xy, vec2(12.9898f, 78.233f))) * 43758.5453f);
}

vec3 MapToHemisphere(vec2 s, vec3 N, float e)
{
    // Construct basis
    vec3 U = OrthoVector(N);
    vec3 V = cross(U, N);
    U = cross(N, V);

    // Calculate 2D sample
    float r1 = s.x;
    float r2 = s.y;

    // Transform to spherical coordinates
    float sinPsi = sin(2.0*PI*r1);
    float cosPsi = cos(2*PI*r1);
    float cosTheta = pow(1.0 - r2, 1.0 / (e + 1.0));
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

    // Return the result
    return normalize(U * sinTheta * cosPsi + V * sinTheta * sinPsi + N * cosTheta);
}

vec2 hash2(float n) { return fract(sin(vec2(n, n + 1.0))*vec2(43758.5453123, 22578.1459123)); }

// Spheremap Transform
vec3 DecodeNormal(uvec2 enc)
{
    vec2 enc_n = vec2(enc.xy) / 65535.0f;
    enc_n = enc_n * 2.0f - vec2(1.0f);

    float scale = 1.7777f;
    vec3 nn = enc_n.xyy * vec3(2.0f*scale, 2.0f * scale, 0.0f) + vec3(-scale, -scale, 1);
    float g = 2.0f / dot(nn.xyz, nn.xyz);
    vec3 n;
    n.xy = g*nn.xy;
    n.z = g - 1;

    return n;
}
vec3 ReconstructVSPositionFromDepth(vec2 uv, float depth)
{
    uv = uv * vec2(2.0f, 2.0f) - vec2(1.0f, 1.0f);

    vec4 projPos = vec4(uv, depth, 1.0f);
    vec4 viewPos = ubo.invProj * projPos;

    return viewPos.xyz / viewPos.w;
}

// Decode depth z/w - 24 bits, mesh id - 8 bits
vec2 DecodeDepthAndMeshID(uvec2 data)
{
    float meshID = float(data.y & 0xFF);
    uint depthHighBits = ((data.y >> 8) & 0xFF) << 16;
    float depth = float(depthHighBits | data.x) / 16777215.0f;

    return vec2(depth, meshID);
}

// Material functions
vec3 GGX_Sample(vec2 s, float roughness, vec3 V, vec3 N)
{
    float a = roughness * roughness;
    float Phi = 2.0 * PI * s.x;
    float CosTheta = sqrt((1.0 - s.y) / (1 + (a*a - 1) * s.y));
    float SinTheta = sqrt(1.0 - CosTheta * CosTheta);

    vec3 H = vec3(SinTheta * cos(Phi), CosTheta, SinTheta * sin(Phi));
    vec3 T = OrthoVector(N);
    vec3 B = cross(T, N);
    T = cross(N, B);

    H = T * H.x + B * H.z + N * H.y;

    return -V + 2.0*abs(dot(V, H)) * H;
}

float GGX_D(float roughness, float NdotH)
{
    float a2 = roughness * roughness;
    float v = (NdotH * NdotH * (a2 - 1) + 1);
    return a2 / (PI * v * v);
}

float GGX_G1(vec3 N, vec3 V, float k)
{
    const float NdotV = clamp(dot(N, V), 0.0, 1.0);
    return NdotV / (NdotV * (1.0 - k) + k);
}

float GGX_G(float roughness, vec3 N, vec3 V, vec3 L)
{
    const float t = roughness + 1.0;
    const float k = t * t / 8.0;

    return GGX_G1(N, V, k) * GGX_G1(N, L, k);
}

vec3 FresnelSchlick(vec3 albedo, vec3 H, vec3 V)
{
    const float VdotH = clamp(dot(V, H), 0.0, 1.0);
    return (albedo + (1.0f - albedo) * pow(1.0 - VdotH, 5.0));
}

float FresnelSchlickIor(float ior, vec3 N, vec3 V)
{
    float R = (1.0 - ior) / (1.0 + ior);
    R *= R;
    const float NdotV = clamp(dot(V, N), 0.0, 1.0);
    return (R + (1.0f - R) * pow(1.0 - NdotV, 5.0));
}



vec3 BRDF_Evaluate(BRDFInputs inputs,
                   vec3 V,
                   vec3 N,
                   vec3 L)
{
    vec3 specAlbedo = mix(vec3(0.03f), inputs.albedo, inputs.metallic);

    vec3 H = normalize(L + V);
    float NdotV = clamp(dot(N, V), 0.0, 1.0);
    float NdotH = clamp(dot(N, H), 0.0, 1.0);
    float NdotL = clamp(dot(N, L), 0.0, 1.0);

    vec3 diffuse = (1.0 - inputs.metallic) * inputs.albedo.xyz / PI;

    float D = GGX_D(inputs.roughness, NdotH);
    float G = GGX_G(inputs.roughness, N, V, L);
    vec3  F = FresnelSchlick(specAlbedo, H, V);
    vec3 specular = (D * G * F) / (4.0f * NdotL * NdotV);

    return diffuse + specular;
}

float BRDF_GetPdf(BRDFInputs inputs,
                  vec3 V,
                  vec3 N,
                  vec3 L)
{
    vec3 specAlbedo = mix(vec3(0.03f), inputs.albedo, inputs.metallic);

    vec3 H = normalize(L + V);
    float NdotL = clamp(dot(N, L), 0.0, 1.0);
    float NdotH = clamp(dot(N, H), 0.0, 1.0);
    float VdotH = clamp(dot(V, H), 0.0, 1.0);
    float D = GGX_D(inputs.roughness, NdotH);

    float diffusePdf = (1.0 - inputs.metallic) * NdotL / PI;
    float specularPdf = inputs.metallic * D * NdotH / (4.0 * VdotH);

    return diffusePdf + specularPdf;
}

vec3 BRDF_Sample(BRDFInputs inputs, 
                 vec3 s,
                 vec3 V,
                 vec3 N,
                 out vec3 L,
                 out float pdf)
{
    if (s.z < inputs.metallic)
    {
        L = GGX_Sample(s.xy, inputs.roughness, V, N);
    }
    else
    {
        L = MapToHemisphere(s.xy, N, 1.0);
    }

    pdf = BRDF_GetPdf(inputs, V, N, L);
    return BRDF_Evaluate(inputs, V, N, L);
}

shared uint ldsRayCount;

// Entry point
void main()
{
    ivec2 bufferSize = textureSize(gBuffer0, 0);

    const vec2 uv = vec2(gl_GlobalInvocationID.x, 
                         gl_GlobalInvocationID.y) / vec2(bufferSize);

    uvec4 encodedData = texture(gBuffer0, uv);

    vec3 N = normalize(DecodeNormal(encodedData.xy));
    N = normalize((ubo.invView * vec4(N, 0.0)).xyz);

    vec3 P = ReconstructVSPositionFromDepth(uv, DecodeDepthAndMeshID(encodedData.zw).x);
    P = (ubo.invView * vec4(P, 1.0)).xyz;

    BRDFInputs inputs;
    inputs.albedo = texture(gBuffer1, uv).xyz;
    vec4 data1 = texture(gBuffer2, uv);
    inputs.roughness = data1.z;
    inputs.metallic = data1.w;
    float transparency = 0.0;//inputs.albedo.x;

    vec3 VP = ubo.viewPos.xyz;
    vec3 V = normalize(VP - P);

    if (dot(N, V) < 0.0)
    {
        N = -N;
    }

    uint groupSize = TILE_SIZE * TILE_SIZE;
    //uint flatGroupIndex = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;
    uint globalIndex = gl_GlobalInvocationID.y * bufferSize.x +
        gl_GlobalInvocationID.x;
    uint localIndex = gl_LocalInvocationID.y * TILE_SIZE +
        gl_LocalInvocationID.x;

    ivec2 st = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    uvec2 samplesNum = imageLoad(sampleCounters, st).xy;
    samplesNum.y += 1;

    imageStore(sampleCounters, st, uvec4(samplesNum, 0, 0));

    if (localIndex == 0)
    {
        ldsRayCount = 0;
    }

    uint frameCount = uint(ubo.viewPos.w);
    uint cmjSequenceIndex = (frameCount + rng[globalIndex % (256 * 256)]) % CMJ_CELL_SAMPLE_COUNT;
    uint cmjPatternIndex = (globalIndex + 1) * (frameCount / CMJ_CELL_SAMPLE_COUNT + 1);

    vec2 cmjSample = SampleCMJ(cmjSequenceIndex, CMJ_CELL_SIZE, cmjPatternIndex);
    vec2 cmjSample0 = SampleCMJ(cmjSequenceIndex, CMJ_CELL_SIZE, cmjPatternIndex + frameCount);

    vec3 L;
    vec3 BRDF;
    float pdf;
    float NdotL;

    if (cmjSample0.y > transparency)
    {
        BRDF = BRDF_Sample(inputs, vec3(cmjSample, cmjSample0.x), V, N, L, pdf);
        P += N * RT_EPSILON;
        NdotL = clamp(dot(N, L), 0.0, 1.0);
    } 
    else
    {
        BRDF = vec3(1.0);
        P -= N * RT_EPSILON;
        pdf = 1.0;
        NdotL = 1.0;
        L = -V;
    }

    Ray myRay;
    bool emitRay = length(BRDF) > 0.0 && pdf > 0.0;
    uint myLocalIndex = 0;

    barrier();

    if (emitRay)
    {
        BRDF = vec3(1.0);
        throughput[globalIndex] = vec4(BRDF * NdotL / pdf, 1.0);
        myLocalIndex = atomicAdd(ldsRayCount, 1);

        myRay.origin = P;
        myRay.direction = normalize(L);
        myRay.max_t = RAY_LENGTH;
        myRay.pixel_idx = globalIndex;
    }

    barrier();

    if (localIndex == 0)
    {
        uint baseGroupIndex = atomicAdd(rayCount, ldsRayCount);
        ldsRayCount = baseGroupIndex;
    }

    barrier();

    if (emitRay)
    {
        rays[ldsRayCount + myLocalIndex] = myRay;
    }
}