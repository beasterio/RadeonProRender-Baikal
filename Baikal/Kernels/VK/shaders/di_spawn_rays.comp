#version 450
#define PI 3.14159265358979323846
#define LIGHT_COUNT 3
#define TILE_SIZE 16
#define RAY_LENGTH 10000.0
#define CMJ_CELL_SIZE 4
#define CMJ_CELL_SAMPLE_COUNT (CMJ_CELL_SIZE * CMJ_CELL_SIZE)
#define RNG_BUFFER_SIZE (256 * 256)
#define EPS 0.00000001f

#define RTE_LIGHT_POINT 1
#define RTE_LIGHT_SPOT 2
#define RTE_LIGHT_DIRECTIONAL 3
#define RTE_LIGHT_IBL 4
#define RTE_LIGHT_AREA 5

struct Light
{
    vec4 position;
    vec4 target;
    vec4 color;
    mat4 viewMatrix;
};

struct RtLight
{
    vec3 position;
    uint type;
    vec4 intensity;
    vec3 direction;
    uint areaLightShapeIdx;
    vec2 spotAngles;
    float iblMultiplier;
    uint iblTexture;
};

struct Ray
{
    vec3 direction;
    float time;
    vec3 origin;
    float max_t;
};

struct Shape
{
    uint indexOffset;
    uint numTriangles;
    uint materialIndex;
    uint unused;
};

struct Vertex
{
    vec4 posUVx;
    vec4 normalUVy;
    vec4 tangent;
};

layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE) in;
layout(binding = 0) uniform usampler2D gBuffer0;
layout(binding = 1) uniform sampler2D gBuffer1;
layout(binding = 2) uniform sampler2D gBuffer2;

layout(binding = 3) buffer Rays
{
    Ray rays[];
};

layout(binding = 4) buffer Rng
{
    uint rng[];
};

layout(binding = 5) uniform UBO
{
    vec4 viewPos;
    mat4 view;
    mat4 invView;
    mat4 invProj;
    vec4 params;
    Light lights[LIGHT_COUNT];
} ubo;

layout(binding = 6) buffer Lights
{
    RtLight rt_lights[];
};

layout(binding = 7) buffer LightSamples
{
    vec4 lightSamples[];
};

layout(binding = 8) buffer Shapes
{
    Shape shapes[];
};

layout(binding = 9) buffer IndexData
{
    uint indices[];
};

layout(binding = 10, std430) buffer VertexData
{
    Vertex vertices[];
};

layout(push_constant) uniform PushConsts
{
    uint numLights;
} pushConsts;


// CMJ sampling
uint Permute(uint i, uint l, uint p)
{
    uint w = l - 1;
    w |= w >> 1;
    w |= w >> 2;
    w |= w >> 4;
    w |= w >> 8;
    w |= w >> 16;

    do
    {
        i ^= p;
        i *= 0xe170893d;
        i ^= p >> 16;
        i ^= (i & w) >> 4;
        i ^= p >> 8;
        i *= 0x0929eb3f;
        i ^= p >> 23;
        i ^= (i & w) >> 1;
        i *= 1 | p >> 27;
        i *= 0x6935fa69;
        i ^= (i & w) >> 11;
        i *= 0x74dcb303;
        i ^= (i & w) >> 2;
        i *= 0x9e501cc3;
        i ^= (i & w) >> 2;
        i *= 0xc860a3df;
        i &= w;
        i ^= i >> 5;
    } while (i >= l);
    return (i + p) % l;
}

float RandFloat(uint i, uint p)
{
    i ^= p;
    i ^= i >> 17;
    i ^= i >> 10;
    i *= 0xb36534e5;
    i ^= i >> 12;
    i ^= i >> 21;
    i *= 0x93fc4795;
    i ^= 0xdf6e307f;
    i ^= i >> 17;
    i *= 1 | p >> 18;
    return i * (1.0 / 4294967808.0);
}

vec2 SampleCMJ(uint s, uint n, uint p)
{
    uint sx = Permute(s % n, n, p * 0xa511e9b3);
    uint sy = Permute(s / n, n, p * 0x63d83595);
    float jx = RandFloat(s, p * 0xa399d265);
    float jy = RandFloat(s, p * 0x711ad6a5);

    return vec2((s % n + (sy + jx) / n) / n, (s / n + (sx + jy) / n) / n);
}

vec3 OrthoVector(vec3 n)
{
    vec3 p;

    if (abs(n.z) > 0.0)
    {
        float k = sqrt(n.y*n.y + n.z*n.z);
        p.x = 0; p.y = -n.z / k; p.z = n.y / k;
    }
    else
    {
        float k = sqrt(n.x*n.x + n.y*n.y);
        p.x = n.y / k; p.y = -n.x / k; p.z = 0;
    }

    return p;
}

float nrand(vec2 n)
{
    return fract(sin(dot(n.xy, vec2(12.9898f, 78.233f))) * 43758.5453f);
}

vec3 MapToHemisphere(vec2 s, vec3 n, float e)
{
    // Construct basis
    vec3 u = OrthoVector(n);
    vec3 v = cross(u, n);
    u = cross(n, v);

    // Calculate 2D sample
    float r1 = s.x;
    float r2 = s.y;

    // Transform to spherical coordinates
    float sinPsi = sin(2 * PI*r1);
    float cosPsi = cos(2 * PI*r1);
    float cosTheta = pow(1.0 - r2, 1.0 / (e + 1.0));
    float sinTheta = sqrt(1.0 - cosTheta * cosTheta);

    // Return the result
    return normalize(u * sinTheta * cosPsi + v * sinTheta * sinPsi + n * cosTheta);
}

vec2 hash2(float n) { return fract(sin(vec2(n, n + 1.0))*vec2(43758.5453123, 22578.1459123)); }

// Spheremap Transform
vec3 DecodeNormal (uvec2 enc)
{
    vec2 enc_n = vec2(enc.xy) / 65535.0f;
    enc_n = enc_n * 2.0f - vec2(1.0f);

    float scale = 1.7777f;
    vec3 nn = enc_n.xyy * vec3(2.0f*scale, 2.0f * scale, 0.0f) + vec3(-scale,-scale,1);
    float g = 2.0f / dot(nn.xyz,nn.xyz);
    vec3 n;
    n.xy = g*nn.xy;
    n.z = g-1;

    return n;
}


vec3 ReconstructVSPositionFromDepth(vec2 uv, float depth)
{
    uv = uv * vec2(2.0f, 2.0f) - vec2(1.0f, 1.0f);

    vec4 projPos = vec4(uv, depth, 1.0f);
    vec4 viewPos = ubo.invProj * projPos;

    return viewPos.xyz / viewPos.w;
}

// Decode depth z/w - 24 bits, mesh id - 8 bits
vec2 DecodeDepthAndMeshID(uvec2 data)
{
    float meshID = float(data.y & 0xFF);
    uint depthHighBits = ((data.y >> 8) & 0xFF) << 16;
    float depth = float(depthHighBits | data.x) / 16777215.0f;

    return vec2(depth, meshID);
}

// Material functions
vec3 GGX_Sample(vec2 s, float roughness, vec3 V, vec3 N)
{
    float a = roughness * roughness;
    float Phi = 2.0 * PI * s.x;
    float CosTheta = sqrt((1.0 - s.y) / (1 + (a*a - 1) * s.y));
    float SinTheta = sqrt(1.0 - CosTheta * CosTheta);

    vec3 H = vec3(SinTheta * cos(Phi), CosTheta, SinTheta * sin(Phi));
    vec3 T = OrthoVector(N);
    vec3 B = cross(T, N);
    T = cross(N, B);

    H = T * H.x + B * H.z + N * H.y;

    return -V + 2.0*abs(dot(V, H)) * H;
}

float GGX_D(float roughness, float NdotH)
{
    float a2 = roughness * roughness;
    float v = (NdotH * NdotH * (a2 - 1) + 1);
    return a2 / (PI * v * v);
}

float GGX_G1(vec3 N, vec3 V, float k)
{
    const float NdotV = clamp(dot(N, V), 0.0, 1.0);
    return NdotV / (NdotV * (1.0 - k) + k);
}

float GGX_G(float roughness, vec3 N, vec3 V, vec3 L)
{
    const float t = roughness + 1.0;
    const float k = t * t / 8.0;

    return GGX_G1(N, V, k) * GGX_G1(N, L, k);
}

vec3 FresnelSchlick(vec3 albedo, vec3 H, vec3 V)
{
    const float VdotH = clamp(dot(V, H), 0.0, 1.0);
    return (albedo + (1.0f - albedo) * pow(1.0 - VdotH, 5.0));
}


struct BRDFInputs
{
    vec3 albedo;
    float roughness;
    float metallic;
    float transparency;
};

vec3 BRDF_Evaluate(BRDFInputs inputs,
                   vec3 V,
                   vec3 N,
                   vec3 L)
{
    vec3 specAlbedo = mix(vec3(0.03f), inputs.albedo, inputs.metallic);

    vec3 H = normalize(L + V);
    float NdotV = clamp(dot(N, V), 0.0, 1.0);
    float NdotH = clamp(dot(N, H), 0.0, 1.0);
    float NdotL = clamp(dot(N, L), 0.0, 1.0);

    vec3 diffuse = (1.0 - inputs.metallic) * inputs.albedo.xyz / PI;

    float D = GGX_D(inputs.roughness, NdotH);
    float G = GGX_G(inputs.roughness, N, V, L);
    vec3  F = FresnelSchlick(specAlbedo, H, V);
    vec3 specular = (D * G * F) / (4.0f * NdotL * NdotV);

    return diffuse + specular;
}

float BRDF_GetPdf(BRDFInputs inputs,
    vec3 V,
    vec3 N,
    vec3 L)
{
    vec3 specAlbedo = mix(vec3(0.03f), inputs.albedo, inputs.metallic);

    vec3 H = normalize(L + V);
    float NdotL = clamp(dot(N, L), 0.0, 1.0);
    float NdotH = clamp(dot(N, H), 0.0, 1.0);
    float VdotH = clamp(dot(V, H), 0.0, 1.0);
    float D = GGX_D(inputs.roughness, NdotH);

    float diffusePdf = (1.0 - inputs.metallic) * NdotL / PI;
    float specularPdf = inputs.metallic * D * NdotH / (4.0 * VdotH);

    return diffusePdf + specularPdf;
}

vec3 BRDF_Sample(BRDFInputs inputs,
                 vec3 s,
                 vec3 V,
                 vec3 N,
                 out vec3 L,
                 out float pdf)
{
    if (s.z < inputs.metallic)
    {
        L = GGX_Sample(s.xy, inputs.roughness, V, N);
    }
    else
    {
        L = MapToHemisphere(s.xy, N, 1.0);
    }

    pdf = BRDF_GetPdf(inputs, V, N, L);
    return BRDF_Evaluate(inputs, V, N, L);
}

// Light functions
vec3 AreaLight_Sample(RtLight light,
                      vec3 s,
                      vec3 P,
                      vec3 N,
                      out vec3 L,
                      out float dist,
                      out float pdf)
{
    uint shapeID = light.areaLightShapeIdx;
    Shape shape = shapes[shapeID];

    uint primID = clamp(uint(s.z * shape.numTriangles), 0u, shape.numTriangles - 1u);

    vec2 bc = vec2(1.0 - sqrt(s.x), s.y * sqrt(s.x));

    uint idx0 = indices[shape.indexOffset + 3 * primID];
    uint idx1 = indices[shape.indexOffset + 3 * primID + 1];
    uint idx2 = indices[shape.indexOffset + 3 * primID + 2];

    Vertex vertexData[3] = { vertices[idx0], vertices[idx1], vertices[idx2] };

    vec3 v0 = vertexData[0].posUVx.xyz;
    vec3 v1 = vertexData[1].posUVx.xyz;
    vec3 v2 = vertexData[2].posUVx.xyz;

    vec3 n0 = vertexData[0].normalUVy.xyz;
    vec3 n1 = vertexData[1].normalUVy.xyz;
    vec3 n2 = vertexData[2].normalUVy.xyz;

    vec3 LP = (1.0 - bc.x - bc.y) * v0 + bc.x * v1 + bc.y * v2;
    vec3 LN = (1.0 - bc.x - bc.y) * n0 + bc.x * n1 + bc.y * n2;

    L = normalize(LP - P);
    dist = distance(LP, P);

    float LNdotL = dot(-L, LN);

    if (LNdotL > 0.0)
    {
        float area = 0.5 * length(cross(v2 - v0, v1 - v0));
        float denom = LNdotL * area;
        pdf = denom > 0.0 ? (dist * dist) / denom : 0.0;
        return light.intensity.xyz;
    }
    else
    {
        pdf = 0.0;
        return vec3(0.0);
    }
}

vec3 Light_Sample(RtLight light, vec3 s, vec3 P, vec3 N, out vec3 L, out float dist, out float pdf)
{
    vec3 I = vec3(0.0);
    switch (light.type)
    {
    case RTE_LIGHT_POINT:
    {
        L = normalize(light.position - P);
        dist = distance(light.position, P);
        I = light.intensity.xyz / (dist * dist);
        pdf = 1.0;
        break;
    }

    case RTE_LIGHT_SPOT:
    {
        L = normalize(light.position - P);
        dist = distance(light.position, P);
        float LdotS = max(0.0, dot(-L, normalize(light.direction.xyz)));
        float spotEffect = smoothstep(light.spotAngles.x, light.spotAngles.y, LdotS);
        I = spotEffect * light.intensity.xyz / (dist * dist);
        pdf = 1.0;
        break;
    }

    case RTE_LIGHT_DIRECTIONAL:
    {
        L = normalize(light.direction.xyz);
        dist = 1000000000.f;
        I = light.intensity.xyz;
        pdf = 1.0;
        break;
    }

    case RTE_LIGHT_AREA:
    {
        I = AreaLight_Sample(light, s, P, N, L, dist, pdf);
        break;
    }

    }
    return I;
}


void main()
{
    ivec2 bufferSize = textureSize(gBuffer0, 0);

    const vec2 uv = vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y) / vec2(bufferSize);

    const uvec4 encodedData = texture(gBuffer0, uv);
    vec3 normal = normalize(DecodeNormal(encodedData.xy));
    vec3 N = normalize((ubo.invView * vec4(normal, 0.0f)).xyz);
    vec3 pos = ReconstructVSPositionFromDepth(uv, DecodeDepthAndMeshID(encodedData.zw).x);
    vec3 wPos = (ubo.invView * vec4(pos, 1.0f)).xyz;

    BRDFInputs inputs;
    inputs.albedo = texture(gBuffer1, uv).xyz;
    vec4 data1 = texture(gBuffer2, uv);
    inputs.roughness = data1.z;
    inputs.metallic = data1.w;


    vec3 VP = ubo.viewPos.xyz;
    vec3 V = normalize(VP - wPos);

    if (dot(N, V) < 0.0)
    {
        N = -N;
    }

    uint groupSize = TILE_SIZE * TILE_SIZE;
    uint flatGroupIndex = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;
    uint rayIndex = flatGroupIndex * groupSize + gl_LocalInvocationID.y * TILE_SIZE + gl_LocalInvocationID.x;

    uint frameCount = uint(ubo.viewPos.w);
    uint cmjSequenceIndex = (frameCount + rng[rayIndex % (256 * 256)]) % CMJ_CELL_SAMPLE_COUNT;
    uint cmjPatternIndex = (rayIndex + 1) * (frameCount / CMJ_CELL_SAMPLE_COUNT + 1);

    vec2 cmjSample = SampleCMJ(cmjSequenceIndex, CMJ_CELL_SIZE, cmjPatternIndex);
    vec2 cmjSample0 = SampleCMJ(cmjSequenceIndex, CMJ_CELL_SIZE, cmjPatternIndex + frameCount);

    uint lightIdx = clamp(uint(cmjSample0.x * pushConsts.numLights), 0u, pushConsts.numLights - 1u);

    Ray myRay;

    vec3 P = wPos + N * 0.3;

    vec3 L;
    float pdf;
    float dist;
    vec3 I = Light_Sample(rt_lights[lightIdx], vec3(cmjSample, cmjSample0.y), P, N, L, dist, pdf);

    if (dot(N, L) > 0.0)
    {
        vec3 BRDF = BRDF_Evaluate(inputs, V, N, L);

        if (pdf > 0.0 && length(BRDF) > 0.0)
        {
            I *= (abs(dot(N, L)) * BRDF / pdf);
        }
        else
        {
            I = vec3(0.0);
        }
    }
    else
    {
        I = vec3(0.0);
    }

    myRay.direction = L;
    myRay.origin = P;
    myRay.max_t = 0.99 * dist;
    rays[rayIndex] = myRay;

    lightSamples[rayIndex] = vec4(I, 1.0);
}