#version 450
#define PI 3.14159265358979323846
#define LIGHT_COUNT 3
#define TILE_SIZE 16

struct Light 
{
    vec4 position;
    vec4 target;
    vec4 color;
    mat4 viewMatrix;
};

layout (local_size_x = TILE_SIZE, local_size_y = TILE_SIZE) in;
layout (binding = 0, rgba32f) uniform image2D giImage;
layout (binding = 1) uniform usampler2D samplerData0;
layout (binding = 2) uniform UBO 
{
    vec4 viewPos;
    mat4 view;
    mat4 invView;
    mat4 invProj;
    vec4 params;
    Light lights[LIGHT_COUNT];
} ubo;

layout (binding = 3, rgba32f) uniform image2D resultImage;

// Spheremap Transform
vec3 DecodeNormal(uvec2 enc)
{
    vec2 enc_n = vec2(enc.xy) / 65535.0f;
    enc_n = enc_n * 2.0f - vec2(1.0f);

    vec4 nn = enc_n.xyxx * vec4(2,2,0,0) + vec4(-1,-1, 1,-1);
    float l = abs(dot(nn.xyz,-nn.xyw));
    nn.z = l;
    nn.xy *= sqrt(l);
    return nn.xyz * 2 + vec3(0,0,-1);
}

// Decode depth z/w - 24 bits, mesh id - 8 bits
vec2 DecodeDepthAndMeshID(uvec2 data)
{
    float meshID 		= float(data.y & 0xFF);
    uint depthHighBits 	= ((data.y >> 8) & 0xFF) << 16;
    float depth 		= float(depthHighBits | data.x) / 16777215.0f;

    return vec2(depth, meshID);
}

vec3 ReconstructVSPositionFromDepth(vec2 uv, float depth)
{
    uv = uv * vec2(2.0f, 2.0f) - vec2(1.0f, 1.0f);

    vec4 projPos = vec4(uv, depth, 1.0f);
    vec4 viewPos = ubo.invProj * projPos;

    return viewPos.xyz / viewPos.w;
}

// Similarity function
float C(vec3 x1, vec3 x2, float sigma)
{
    float a = length(x1 - x2) / sigma;
    a *= a;
    return exp(-0.5f * a);
}

void main() 
{
    const vec4 colorSample =  imageLoad(giImage, ivec2(gl_GlobalInvocationID.xy));    
    const vec3 color =  colorSample.xyz / max(colorSample.w, 1.0f);

    ivec2 bufferSize = textureSize(samplerData0, 0);

    const vec2 uv = vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y) / vec2(bufferSize);

    const uvec4 encodedData = texture(samplerData0, uv);
    const vec2 depthAndMeshID = DecodeDepthAndMeshID(encodedData.zw);

    const vec3 vNormal  = normalize(DecodeNormal(encodedData.xy));
    const vec3 vPos     = ReconstructVSPositionFromDepth(uv, depthAndMeshID.x);
    const float meshID  = depthAndMeshID.y;

    vec3 filteredColor = vec3(0.f);
    float weightSum = 0.f;

    const int radius = 3;

    if (length(vPos) > 0.f)
    {
         for (int i = -radius; i <= radius; ++i)
            {
                for (int j = -radius; j <= radius; ++j)
                {
                    const ivec2 currentInvocationID = clamp(ivec2(gl_GlobalInvocationID.xy) + ivec2(i, j), ivec2(0, 0), bufferSize);
                    const vec2 currentUV = vec2(currentInvocationID) / vec2(bufferSize);

                    const uvec4 encodedData = texture(samplerData0, currentUV);
                    const vec2 depthAndMeshID = DecodeDepthAndMeshID(encodedData.zw);

                    const vec4 colorSample = imageLoad(giImage, currentInvocationID);

                    const vec3 c    = colorSample.xyz / max(colorSample.w, 1.0f);
                    const vec3 p    = ReconstructVSPositionFromDepth(currentUV, depthAndMeshID.x);
                    const vec3 n    = normalize(DecodeNormal(encodedData.xy));

                    if (meshID == depthAndMeshID.y && length(p) > 0 && isnan(c) == bvec3(false))
                    {                       
                        const float position_weight      = C(p, vPos, 0.1f);
                        const float normal_weight       = pow(max(0.f, dot(vNormal, n)), 128.f);

                        float weight = normal_weight * position_weight;

                        filteredColor += weight * c;
                        weightSum += weight;
                    }
                }
            }
    }

    vec3 result = weightSum > 0.f ? filteredColor / weightSum : color;
    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), vec4(result, 1.0f));
    //imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), colorSample);
}