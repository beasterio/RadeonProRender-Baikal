#version 450
#define PI 3.14159265358979323846
#define LIGHT_COUNT 3
#define TILE_SIZE 16

struct Light 
{
    vec4 position;
    vec4 target;
    vec4 color;
    mat4 viewMatrix;
};

layout (local_size_x = TILE_SIZE, local_size_y = TILE_SIZE) in;
layout (binding = 0, rgba16f) uniform image2D image;
layout (binding = 1, rg16ui) uniform uimage2D sampleCount;
layout (binding = 2) uniform usampler2D samplerData0;
layout (binding = 3) uniform UBO 
{
    vec4 viewPos;
    mat4 view;
    mat4 invView;
    mat4 invProj;
    vec4 params;
    Light lights[LIGHT_COUNT];
} ubo;

layout (binding = 4, rgba16f) uniform image2D resultImage;

// Stereographic Projection
vec3 DecodeNormal (uvec2 enc)
{
    vec2 enc_n = vec2(enc.xy) / 65535.0f;
    enc_n = enc_n * 2.0f - vec2(1.0f);

    float scale = 1.7777f;
    vec3 nn = enc_n.xyy * vec3(2.0f*scale, 2.0f * scale, 0.0f) + vec3(-scale,-scale,1);
    float g = 2.0f / dot(nn.xyz,nn.xyz);
    vec3 n;
    n.xy = g*nn.xy;
    n.z = g-1;

    return n;
}

// Decode depth z/w - 24 bits, mesh id - 8 bits
vec2 DecodeDepthAndMeshID(uvec2 data)
{
    float meshID 		= float(data.y & 0xFF);
    uint depthHighBits 	= ((data.y >> 8) & 0xFF) << 16;
    float depth 		= float(depthHighBits | data.x) / 16777215.0f;

    return vec2(depth, meshID);
}

vec3 ReconstructVSPositionFromDepth(vec2 uv, float depth)
{
    uv = uv * vec2(2.0f, 2.0f) - vec2(1.0f, 1.0f);

    vec4 projPos = vec4(uv, depth, 1.0f);
    vec4 viewPos = ubo.invProj * projPos;

    return viewPos.xyz / viewPos.w;
}

// Similarity function
float C(vec3 x1, vec3 x2, float sigma)
{
    float a = length(x1 - x2) / sigma;
    a *= a;
    return exp(-0.5f * a);
}

void main() 
{
    const vec4 sampleValue =  imageLoad(image, ivec2(gl_GlobalInvocationID.xy));

    ivec2 bufferSize = textureSize(samplerData0, 0);

    const vec2 uv = vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y) / vec2(bufferSize);

    const uvec4 encodedData = texture(samplerData0, uv);
    const vec2 depthAndMeshID = DecodeDepthAndMeshID(encodedData.zw);

    const vec3 vNormal  = normalize(DecodeNormal(encodedData.xy));
    const vec3 vPos     = ReconstructVSPositionFromDepth(uv, depthAndMeshID.x);
    const float meshID  = depthAndMeshID.y;

    vec3    filteredGI = vec3(0.f);
    float   filteredAO = 0.f;

    float weightSum = 0.f;

    const int radius = 3;

    if (length(vPos) > 0.f)
    {
         for (int i = -radius; i <= radius; ++i)
            {
                for (int j = -radius; j <= radius; ++j)
                {
                    const ivec2 currentInvocationID = clamp(ivec2(gl_GlobalInvocationID.xy) + ivec2(i, j), ivec2(0, 0), bufferSize);
                    const vec2 currentUV = vec2(currentInvocationID) / vec2(bufferSize);

                    const uvec4 encodedData = texture(samplerData0, currentUV);
                    const vec2 depthAndMeshID = DecodeDepthAndMeshID(encodedData.zw);

                    const vec4 sampleValue = imageLoad(image, currentInvocationID);
                    const uvec2 numSamples = imageLoad(sampleCount, ivec2(gl_GlobalInvocationID.xy)).xy;

                    const float ao =  sampleValue.w / max(numSamples.x, 1.0f);
                    const vec3  gi =  sampleValue.xyz / max(numSamples.y, 1.0f);

                    const vec3 p    = ReconstructVSPositionFromDepth(currentUV, depthAndMeshID.x);
                    const vec3 n    = normalize(DecodeNormal(encodedData.xy));

                    if (meshID == depthAndMeshID.y && length(p) > 0 && isnan(gi) == bvec3(false))
                    {                       
                        const float position_weight     = C(p, vPos, 0.1f);
                        const float normal_weight       = pow(max(0.f, dot(vNormal, n)), 128.f);

                        float weight = normal_weight * position_weight;

                        filteredGI += weight * gi;
                        filteredAO += weight * ao;

                        weightSum += weight;
                    }
                }
            }
    }

    vec4 result = weightSum > 0.f ? vec4(filteredGI, filteredAO)  / weightSum : sampleValue;
    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), result);
}