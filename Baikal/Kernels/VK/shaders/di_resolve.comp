#version 450
#define PI 3.14159265358979323846
#define LIGHT_COUNT 3
#define TILE_SIZE 16
#define INVALID_ADDR 0xffffffffu

#define EPS 0.00000001f

#define RTE_LIGHT_UNKNOWN 0
#define RTE_LIGHT_POINT 1
#define RTE_LIGHT_SPOT 2
#define RTE_LIGHT_DIRECTIONAL 3
#define RTE_LIGHT_IBL 4
#define RTE_LIGHT_AREA 5

struct Light
{
    vec4 position;
    vec4 target;
    vec4 color;
    mat4 viewMatrix;
};

struct Ray
{
    vec3 direction;
    float time;
    vec3 origin;
    float max_t;
};

struct Hit
{
    uint shape_id;
    uint prim_id;
    vec2 uv;
};

struct Shape
{
    uint indexOffset;
    uint numTriangles;
    uint materialIndex;
    uint unused;
};

struct Texture
{
    uint w, h;
    uint dataOffset;
    uint unused;
};

struct Material
{
    vec3 diffuse;
    uint diffuseMap;
    vec3 specular;
    uint specularMap;
    float roughness;
    uint roughnessMap;
    float metalness;
    uint metalnessMap;
};

layout(local_size_x = TILE_SIZE, local_size_y = TILE_SIZE) in;
layout(binding = 0) uniform usampler2D gBuffer0;
layout(binding = 1) uniform sampler2D gBuffer1;
layout(binding = 2) uniform sampler2D gBuffer2;
layout(binding = 3, rgba16f) uniform image2D resultImage;
layout(binding = 4, rg16ui) uniform uimage2D sampleCounters;
layout(binding = 5) buffer Rays
{
    Ray rays[];
};
layout(binding = 6) buffer Hits
{
    Hit hits[];
};

layout(binding = 7) buffer LightSamples
{
    vec4 lightSamples[];
};

layout(binding = 8) uniform UBO
{
    vec4 viewPos;
    mat4 view;
    mat4 invView;
    mat4 invProj;
    vec4 params;
    Light lights[LIGHT_COUNT];
} ubo;



layout(binding = 9) buffer Shapes
{
    Shape shapes[];
};

layout(binding = 10) buffer Materials
{
    Material materials[];
};

layout(binding = 11) buffer IndexData
{
    uint indices[];
};

struct Vertex
{
    vec4 posUVx;
    vec4 normalUVy;
    vec4 tangent;
};

layout(binding = 12, std430) buffer VertexData
{
    Vertex vertices[];
};

layout(binding = 13) buffer TextureDescriptors
{
    Texture textures[];
};

layout(binding = 14) buffer TextureData
{
    uint textureData[];
};


layout(binding = 15) uniform sampler2D samplerShadowMapLight0;
layout(binding = 16) uniform sampler2D samplerShadowMapLight1;
layout(binding = 17) uniform sampler2D samplerShadowMapLight2;


// Spheremap Transform
vec3 DecodeNormal(uvec2 enc)
{
    vec2 enc_n = vec2(enc.xy) / 65535.0f;
    enc_n = enc_n * 2.0f - vec2(1.0f);

    vec4 nn = enc_n.xyxx * vec4(2, 2, 0, 0) + vec4(-1, -1, 1, -1);
    float l = abs(dot(nn.xyz, -nn.xyw));
    nn.z = l;
    nn.xy *= sqrt(l);
    return nn.xyz * 2 + vec3(0, 0, -1);
}

vec3 ReconstructVSPositionFromDepth(vec2 uv, float depth)
{
    uv = uv * vec2(2.0f, 2.0f) - vec2(1.0f, 1.0f);

    vec4 projPos = vec4(uv, depth, 1.0f);
    vec4 viewPos = ubo.invProj * projPos;

    return viewPos.xyz / viewPos.w;
}

// Decode depth z/w - 24 bits, mesh id - 8 bits
vec2 DecodeDepthAndMeshID(uvec2 data)
{
    float meshID = float(data.y & 0xFF);
    uint depthHighBits = ((data.y >> 8) & 0xFF) << 16;
    float depth = float(depthHighBits | data.x) / 16777215.0f;

    return vec2(depth, meshID);
}

vec4 Fetch_UnpackedTextureData(uint offset)
{
    uint data = textureData[offset];
    uvec4 unpacked_data = uvec4(data & 0x000000FF,
        (data & 0x0000FF00) >> 8,
        (data & 0x00FF0000) >> 16,
        (data & 0xFF000000) >> 24);

    return vec4(unpacked_data / 255.0f);
}

vec4 Texture_Sample2D(uint textureIdx, vec2 uv)
{
    // Get width and height
    uint width = textures[textureIdx].w;
    uint height = textures[textureIdx].h;
    uint offset = textures[textureIdx].dataOffset;

    // Handle UV wrap
    uv -= floor(uv);

    // Reverse Y:
    // it is needed as textures are loaded with Y axis going top to down
    // and our axis goes from down to top
    // uv.y = 1.0 - uv.y;

    // Calculate integer coordinates
    uint x0 = clamp(uint(floor(uv.x * width)), 0, width - 1);
    uint y0 = clamp(uint(floor(uv.y * height)), 0, height - 1);

    // Calculate samples for linear filtering
    uint x1 = clamp(x0 + 1, 0, width - 1);
    uint y1 = clamp(y0 + 1, 0, height - 1);

    // Calculate weights for linear filtering
    float wx = uv.x * width - floor(uv.x * width);
    float wy = uv.y * height - floor(uv.y * height);

    vec4 val00 = Fetch_UnpackedTextureData(offset + width * y0 + x0);
    vec4 val01 = Fetch_UnpackedTextureData(offset + width * y0 + x1);
    vec4 val10 = Fetch_UnpackedTextureData(offset + width * y1 + x0);
    vec4 val11 = Fetch_UnpackedTextureData(offset + width * y1 + x1);

    return mix(mix(val00, val01, wx), mix(val10, val11, wx), wy);
}

float textureProj(int lightIdx, vec4 P, vec2 offset)
{
    float shadow = 1.0;
    vec4 shadowCoord = P / P.w;
    shadowCoord.st = shadowCoord.st * 0.5 + 0.5;

    if (shadowCoord.z > -1.0 && shadowCoord.z < 1.0)
    {
        float dist = 0.f;

        // TODO: deferred shadows or texture array?
        switch (lightIdx)
        {
        case 0: dist = texture(samplerShadowMapLight0, vec2(shadowCoord.st + offset)).r; break;
        case 1: dist = texture(samplerShadowMapLight1, vec2(shadowCoord.st + offset)).r; break;
        case 2: dist = texture(samplerShadowMapLight2, vec2(shadowCoord.st + offset)).r; break;
        };

        if (shadowCoord.w > 0.0 && dist < shadowCoord.z)
        {
            shadow = 0.3;
        }
    }
    return shadow;
}

float filterPCF(int lightIdx, vec4 sc)
{
    ivec2 texDim = textureSize(samplerShadowMapLight0, 0).xy;
    float scale = 1.5;
    float dx = scale * 1.0 / float(texDim.x);
    float dy = scale * 1.0 / float(texDim.y);

    float shadowFactor = 0.0;
    int count = 0;
    int range = 1;

    for (int x = -range; x <= range; x++)
    {
        for (int y = -range; y <= range; y++)
        {
            shadowFactor += textureProj(lightIdx, sc, vec2(dx*x, dy*y));
            count++;
        }

    }
    return shadowFactor / count;
}

vec3 BRDF_Diffuse(vec3 wi, vec3 wo, vec3 albedo)
{
    return albedo / PI;
}

float DTerm_GGX(float roughness, float NdotH)
{
    float roughness2 = roughness * roughness;
    float v = (NdotH * NdotH * (roughness2 - 1) + 1);
    return roughness2 / (PI * v * v);
}


float G1(vec3 n, vec3 v, float k)
{
    const float NdotV = clamp(dot(n, v), 0.f, 1.f);
    return NdotV / (NdotV * (1 - k) + k);
}

float GTerm(float roughness, vec3 n, vec3 v, vec3 l)
{
    const float t = roughness + 1;
    const float k = t * t / 8.f;

    return G1(n, v, k) * G1(n, l, k);
}

float FTerm(float F0, vec3 v, vec3 h)
{
    const float VdotH = clamp(dot(v, h), 0.f, 1.f);
    float p = (-5.55473 * VdotH - 6.98316) * VdotH;

    return F0 + (1 - F0) * pow(2.f, p);
}

// Schlick approximation
vec3 FTerm(vec3 specularColor, vec3 h, vec3 v)
{
    const float VdotH = clamp(dot(v, h), 0.f, 1.f);
    return (specularColor + (1.0f - specularColor) * pow(1.0f - VdotH, 5));
}


void main()
{
    uint groupSize = TILE_SIZE * TILE_SIZE;
    uint flatGroupIndex = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;
    uint rayIndex = flatGroupIndex * groupSize + gl_LocalInvocationID.y * TILE_SIZE + gl_LocalInvocationID.x;

    ivec2 bufferSize = textureSize(gBuffer0, 0);

    const vec2 uv = vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y) / vec2(bufferSize);

    const uvec4 encodedData = texture(gBuffer0, uv);
    vec3 albedo = texture(gBuffer1, uv).xyz;
    vec4 data1 = texture(gBuffer2, uv);
    float roughness = data1.z;
    float metallic = data1.w;

    vec3 realSpecularColor = mix(vec3(0.03f), albedo.rgb, metallic);
    vec3 normal = normalize(DecodeNormal(encodedData.xy));
    vec3 N = normalize((ubo.invView * vec4(normal, 0.0f)).xyz);
    vec3 pos = ReconstructVSPositionFromDepth(uv, DecodeDepthAndMeshID(encodedData.zw).x);
    vec3 P = (ubo.invView * vec4(pos, 1.0f)).xyz;

    vec3 viewPos = ubo.viewPos.xyz;
    vec3 V = normalize(viewPos.xyz - P);
    vec4 value = imageLoad(resultImage, ivec2(gl_GlobalInvocationID.xy));

    uint shapeID = hits[rayIndex].shape_id;
    if (shapeID == INVALID_ADDR)
    {
        value += vec4(lightSamples[rayIndex].xyz, 0.0);
    }

    uvec2 samplesNum = imageLoad(sampleCounters, ivec2(gl_GlobalInvocationID.xy)).xy;
    samplesNum.y += 1;

    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), value);
    imageStore(sampleCounters, ivec2(gl_GlobalInvocationID.xy), uvec4(samplesNum, 0, 0));
}