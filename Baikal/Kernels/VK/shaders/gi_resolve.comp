#version 450
#define PI 3.14159265358979323846
#define LIGHT_COUNT 3
#define TILE_SIZE 16
#define INVALID_ADDR 0xffffffffu

#define EPS 0.00000001f

struct Light 
{
    vec4 position;
    vec4 target;
    vec4 color;
    mat4 viewMatrix;
};

struct Ray
{
  vec3 direction;
  float time;
  vec3 origin;
  float max_t;
};

struct Hit 
{
    uint shape_id;
    uint prim_id;
    vec2 uv;
};

struct Shape
{
	uint indexOffset;
	uint numTriangles;
	uint materialIndex;
	uint unused;
};

struct Texture
{
    uint w, h;
    uint dataOffset;
	uint unused;
};

struct Material
{
	vec3 diffuse;
	uint diffuseMap;
	vec3 specular;
	uint specularMap;
	float roughness;
	uint roughnessMap;
	float metalness;
	uint metalnessMap;
};



layout (local_size_x = TILE_SIZE, local_size_y = TILE_SIZE) in;
layout (binding = 0, rgba32f) uniform image2D resultImage;
layout (binding = 1) uniform UBO 
{
    vec4 viewPos;
    mat4 view;
    mat4 invView;
    mat4 invProj;
    vec4 params;
    Light lights[LIGHT_COUNT];
} ubo;
layout(binding = 2) buffer Hits 
{
  Hit hits[];
};


layout (binding = 3) buffer Shapes
{
	Shape shapes[];
};

layout (binding = 4) buffer Materials
{
	Material materials[];
};

layout (binding = 5) buffer IndexData
{
	uint indices[];
};

struct Vertex
{
    vec3 pos;
	vec3 normal;
    vec2 uv;
};

layout (binding = 6, std430) buffer VertexData
{
	Vertex vertices[];
};

layout (binding = 7) buffer Rays
{
	Ray rays[];
};

layout(binding = 8) buffer TextureDescriptors 
{
	Texture textures[];
};

layout(binding = 9) buffer TextureData 
{
	uint textureData[];
};

layout (binding = 10) uniform usampler2D gBuffer0;
layout (binding = 11) uniform sampler2D gBuffer1;
layout (binding = 12) uniform sampler2D gBuffer2;
layout (binding = 13) uniform sampler2D samplerShadowMapLight0;
layout (binding = 14) uniform sampler2D samplerShadowMapLight1;
layout (binding = 15) uniform sampler2D samplerShadowMapLight2;


layout(push_constant) uniform PushConsts
{
	int clear;
} pushConsts;

// Spheremap Transform
vec3 DecodeNormal(uvec2 enc)
{
    vec2 enc_n = vec2(enc.xy) / 65535.0f;
    enc_n = enc_n * 2.0f - vec2(1.0f);

    vec4 nn = enc_n.xyxx * vec4(2,2,0,0) + vec4(-1,-1, 1,-1);
    float l = abs(dot(nn.xyz,-nn.xyw));
    nn.z = l;
    nn.xy *= sqrt(l);
    return nn.xyz * 2 + vec3(0,0,-1);
}

vec3 ReconstructVSPositionFromDepth(vec2 uv, float depth)
{
    uv = uv * vec2(2.0f, 2.0f) - vec2(1.0f, 1.0f);

    vec4 projPos = vec4(uv, depth, 1.0f);
    vec4 viewPos = ubo.invProj * projPos;

    return viewPos.xyz / viewPos.w;
}

// Decode depth z/w - 24 bits, mesh id - 8 bits
vec2 DecodeDepthAndMeshID(uvec2 data)
{
    float meshID 		= float(data.y & 0xFF);
    uint depthHighBits 	= ((data.y >> 8) & 0xFF) << 16;
    float depth 		= float(depthHighBits | data.x) / 16777215.0f;

    return vec2(depth, meshID);
}

vec4 Fetch_UnpackedTextureData(uint offset)
{
  uint data = textureData[offset];
  uvec4 unpacked_data = uvec4(  data & 0x000000FF, 
                                (data & 0x0000FF00) >> 8, 
                                (data & 0x00FF0000) >> 16, 
                                (data & 0xFF000000) >> 24);

  return vec4(unpacked_data / 255.0f);
}

vec4 Texture_Sample2D(uint textureIdx, vec2 uv)
{
   // Get width and height
   uint width = textures[textureIdx].w;
   uint height = textures[textureIdx].h;
   uint offset = textures[textureIdx].dataOffset;

   // Handle UV wrap
   uv -= floor(uv);

   // Reverse Y:
   // it is needed as textures are loaded with Y axis going top to down
   // and our axis goes from down to top
   // uv.y = 1.0 - uv.y;

   // Calculate integer coordinates
   uint x0 = clamp(uint(floor(uv.x * width)), 0, width - 1);
   uint y0 = clamp(uint(floor(uv.y * height)), 0, height - 1);

   // Calculate samples for linear filtering
   uint x1 = clamp(x0 + 1, 0, width - 1);
   uint y1 = clamp(y0 + 1, 0, height - 1);

   // Calculate weights for linear filtering
   float wx = uv.x * width - floor(uv.x * width);
   float wy = uv.y * height - floor(uv.y * height);

   vec4 val00 = Fetch_UnpackedTextureData(offset + width * y0 + x0);
   vec4 val01 = Fetch_UnpackedTextureData(offset + width * y0 + x1);
   vec4 val10 = Fetch_UnpackedTextureData(offset + width * y1 + x0);
   vec4 val11 = Fetch_UnpackedTextureData(offset + width * y1 + x1);
    
   return mix(mix(val00, val01, wx), mix(val10, val11, wx), wy);
}

float textureProj(int lightIdx, vec4 P, vec2 offset)
{
    float shadow = 1.0;
    vec4 shadowCoord = P / P.w;
    shadowCoord.st = shadowCoord.st * 0.5 + 0.5;
    
    if (shadowCoord.z > -1.0 && shadowCoord.z < 1.0) 
    {
        float dist = 0.f;

        // TODO: deferred shadows or texture array?
        switch(lightIdx)
        {
            case 0 : dist = texture(samplerShadowMapLight0, vec2(shadowCoord.st + offset)).r; break;
            case 1 : dist = texture(samplerShadowMapLight1, vec2(shadowCoord.st + offset)).r; break;
            case 2 : dist = texture(samplerShadowMapLight2, vec2(shadowCoord.st + offset)).r; break;
        };

        if (shadowCoord.w > 0.0 && dist < shadowCoord.z) 
        {
            shadow = 0.3;
        }
    }
    return shadow;
}

float filterPCF(int lightIdx, vec4 sc)
{
    ivec2 texDim = textureSize(samplerShadowMapLight0, 0).xy;
    float scale = 1.5;
    float dx = scale * 1.0 / float(texDim.x);
    float dy = scale * 1.0 / float(texDim.y);

    float shadowFactor = 0.0;
    int count = 0;
    int range = 1;
    
    for (int x = -range; x <= range; x++)
    {
        for (int y = -range; y <= range; y++)
        {
            shadowFactor += textureProj(lightIdx, sc, vec2(dx*x, dy*y));
            count++;
        }
    
    }
    return shadowFactor / count;
}

float DTerm_GGX(float roughness, float NdotH)
{
    float roughness2 = roughness * roughness;
    float v = (NdotH * NdotH * (roughness2 - 1) + 1);
    return roughness2 / (PI * v * v);
}


float G1(vec3 n, vec3 v, float k)
{
    const float NdotV = clamp(dot(n, v), 0.f, 1.f);
    return NdotV / (NdotV * (1 - k) + k);
}

float GTerm(float roughness, vec3 n, vec3 v, vec3 l)
{
    const float t = roughness + 1;
    const float k = t * t / 8.f;

    return G1(n, v, k) * G1(n, l, k);
}

float FTerm(float F0, vec3 v, vec3 h)
{
    const float VdotH = clamp(dot(v, h), 0.f, 1.f);
    float p = (-5.55473 * VdotH - 6.98316) * VdotH;

    return F0 + (1 - F0) * pow(2.f, p);
}

// Schlick approximation
vec3 FTerm(vec3 specularColor, vec3 h, vec3 v)
{
    const float VdotH = clamp(dot(v, h), 0.f, 1.f);
    return (specularColor + (1.0f - specularColor) * pow(1.0f - VdotH, 5));
}


void main() 
{
    uint groupSize = TILE_SIZE * TILE_SIZE;
    uint flatGroupIndex = gl_WorkGroupID.y * gl_NumWorkGroups.x + gl_WorkGroupID.x;
    uint rayIndex = flatGroupIndex * groupSize + gl_LocalInvocationID.y * TILE_SIZE + gl_LocalInvocationID.x;

	ivec2 bufferSize = textureSize(gBuffer0, 0);
    
    const vec2 uv = vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y) / vec2(bufferSize);
    
    const uvec4 encodedData = texture(gBuffer0, uv);
	vec3 albedo = texture(gBuffer2, uv).xyz;
	vec4 data1 = texture(gBuffer1, uv);	
    float roughness = data1.z;
    float metallic = data1.w;
	
	vec3 realSpecularColor = mix( vec3(0.03f), albedo.rgb, metallic);
    vec3 realAlbedo = clamp( albedo.rgb - albedo.rgb * metallic, vec3(0.f), vec3(1.0f) );
	
    vec3 normal = normalize(DecodeNormal(encodedData.xy));
	vec3 N = normalize((ubo.invView * vec4(normal, 0.0f)).xyz);
	vec3 pos = ReconstructVSPositionFromDepth(uv, DecodeDepthAndMeshID(encodedData.zw).x);
	vec3 wPos = (ubo.invView * vec4(pos, 1.0f)).xyz;
	
	vec3 viewPos = ubo.viewPos.xyz;
    viewPos.y = -viewPos.y;
	
	vec3 wView = normalize(viewPos.xyz - wPos);
    vec4 value = pushConsts.clear == 1 ? vec4(0.0f) : imageLoad(resultImage, ivec2(gl_GlobalInvocationID.xy));

	uint shapeID = hits[rayIndex].shape_id;
    if (shapeID != INVALID_ADDR)
    {
		uint primID = hits[rayIndex].prim_id;
		Shape shape = shapes[shapeID];
		
		vec2 bc = hits[rayIndex].uv;
		
		uint idx0 = indices[shape.indexOffset + 3 * primID];
		uint idx1 = indices[shape.indexOffset + 3 * primID + 1];
		uint idx2 = indices[shape.indexOffset + 3 * primID + 2];
		
		vec3 v0 = vertices[idx0].pos;
		vec3 v1 = vertices[idx1].pos;
		vec3 v2 = vertices[idx2].pos;
		
		vec3 n0 = vertices[idx0].normal;
		vec3 n1 = vertices[idx1].normal;
		vec3 n2 = vertices[idx2].normal;
		
		vec2 uv0 = vertices[idx0].uv;
		vec2 uv1 = vertices[idx1].uv;
		vec2 uv2 = vertices[idx2].uv;
		
		vec3 v = (1.0 - bc.x - bc.y) * v0 + bc.x * v1 + bc.y * v2;
		vec3 n = (1.0 - bc.x - bc.y) * n0 + bc.x * n1 + bc.y * n2;
		vec2 tex = (1.0 - bc.x - bc.y) * uv0 + bc.x * uv1 + bc.y * uv2;
		
		if (dot(n, rays[rayIndex].direction) > 0.0)
		{
			n = -n;
		}
	
		Material material = materials[shape.materialIndex];
		vec3 secondaryAlbedo = Texture_Sample2D(material.diffuseMap, tex).xyz;
        secondaryAlbedo *= material.diffuse;

		vec3 estimate = vec3(0.0);
		
		for(int i = 0; i < LIGHT_COUNT; ++i)
		{
			vec4 shadowClip	= ubo.lights[i].viewMatrix * vec4(v, 1);
			float shadowFactor = 1.0;//filterPCF(i, shadowClip);

			// Vector to light
			vec3 L = ubo.lights[i].position.xyz - v;
			// Distance from light to fragment position
			float dist = length(L);
			L = normalize(L);

			// Viewer to fragment
			vec3 V = -rays[rayIndex].direction;

			float lightCosInnerAngle = cos(radians(15.0));
			float lightCosOuterAngle = cos(radians(25.0));

			// Direction vector from source to target
			vec3 dir = normalize(ubo.lights[i].position.xyz - ubo.lights[i].target.xyz);

			// Dual cone spot light with smooth transition between inner and outer angle
			float cosDir = dot(L, dir);
			float spotEffect = smoothstep(lightCosOuterAngle, lightCosInnerAngle, cosDir);

			vec3 H = normalize(L + V);
			float NdotV = clamp(dot(n, V), 0.f, 1.f);
			float NdotH = clamp(dot(n, H), 0.f, 1.f);

			// Diffuse lighting
			float NdotL = max(0.0, dot(n, L));

			// Specular lighting
			float 	Dterm = DTerm_GGX(roughness, NdotH);
			float 	Gterm = GTerm(roughness, n, V, L);
			vec3	Fterm = FTerm(realSpecularColor, H, V);
			vec3 	spec = ( Dterm * Gterm * Fterm ) / (4.0f * NdotL * NdotV + EPS);
			vec3 diff = realAlbedo;
			
			
			estimate += (diff) * (secondaryAlbedo / PI) * spotEffect * shadowFactor * ubo.lights[i].color.rgb * PI / (dist * dist);
		}  	
	
		value.xyz += estimate;
	}

    value.w += 1.0;

    imageStore(resultImage, ivec2(gl_GlobalInvocationID.xy), value);
}